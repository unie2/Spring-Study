## ✔ 이야기 - 스프링의 탄생
### 1. 스프링의 역사
  - 2002년 로드 존슨 책 출간
  - `EJB`의 문제점 지적
    - EJB 없이도 충분히 고품질의 확장 가능한 애플리케이션을 개발할 수 있음을 보여주고, 30,000라인 이상의 기반 기술을 예제 코드로 선보임
 
  | 릴리즈 | 내용 |
  |:--------:|:--------:|
  | 2003년 스프링 프레임워크 1.0 출시 | XML |
  | 2006년 스프링 프레임워크 2.0 출시 | XML 편의 기능 지원 |
  | 2009년 스프링 프레임워크 3.0 출시 | 자바 코드로 설정 |
  | 2013년 스프링 프레임워크 4.0 출시 | 자바 8
  | 2014년 스프링 부트 1.0 출시 | |
  | 2017년 스프링 프레임워크 5.0, 스프링 부트 2.0 출시 | 리액티브 프로그래밍 지원 |
  | 2020년 9월 스프링 프레임워크 5.2.x, 스프링 부트 2.3.x | |
  
- - -
## ✔ 스프링이란?
스프링은 여러 가지 기술들의 모음이라고 볼 수 있다.
  - [필수] 스프링 프레임워크, 스프링 부트
  - [선택] 
    - __스프링 데이터__ : NoSQL, MongoDB, Redis 등의 CRUD를 편리하게 할 수 있도록 도와주는 기술이며, 스프링 데이터 JPA를 가장 많이 사용
    - __스프링 세션__ : 세션 기능을 편리하게 할 수 있도록 도와주는 기술
    - __스프링 시큐리티__ : 보안과 관련된 기술
    - __스프링 Rest Docs__ : API 문서화를 편리하게 할 수 있도록 도와주는 기술
    - __스프링 배치__ : 배치 처리에 특화된 기술
    - __스프링 클라우드__ : 클라우드에 특화된 기술
```
배치 처리: 데이터를 천 만건 중에서 100건씩 혹은 1,000건씩 퍼올려서 처리해 저장하는 방식
```

### 1. 스프링 프레임워크
- __핵심 기술__ : 스프링 DI 컨테이너, AOP, 이벤트, 기타
- __웹 기술__ : 스프링 MVC, 스프링 WebFlux
- __데이터 접근 기술__ : 트랜잭션, JDBC, ORM 지원, XML 지원
- __기술 통합__ : 캐시, 이메일, 원격접근, 스케줄링
- __테스트__ : 스프링 기반 테스트 지원
- __언어__ : 코틀린, 그루비
- 최근에는 `스프링 부트`를 통해 스프링 프레임워크의 기술들을 편리하게 사용

### 2. 스프링 부트
- `단독으로 실행`할 수 있는 스프링 애플리케이션을 쉽게 생성
- `Tomcat` 같은 웹 서버를 `내장`해서 별도의 웹 서버를 설치하지 않아도 된다.
- 손쉬운 빌드 구성을 위한 `starter 종속성` 제공
- 스프링과 3rd party(외부) 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정

### 💡 스프링의 진짜 핵심
- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - `객체 지향 언어`
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 `좋은 객체 지향` 애플리케이션을 개발할 수 있게 도와주는 프레임워크

- - -
## ✔ 좋은 객체 지향 프로그래밍이란?
### 1. 객체 지향 특징
- 추상화, 캡슐화, 상속, `다형성`
- 다형성의 실세계 비유
  - 운전자 - 자동차, 공연 무대, 키보드·마우스·세상의 표준 인터페이스들, 정렬 알고리즘, 할인 정책 로직
```
운전자 - 자동차 : 자동차가 변경되어도 운전자는 대상의 역할(인터페이스)만 알면 된다.
```
### 2. 객체 지향 프로그래밍
- 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 `객체들의 모임`으로 파악하고자 하는 것
- 각각의 `객체`는 `메시지`를 주고받고, 데이터를 처리할 수 있다. `(협력)`
- 프로그램을 `유연`하고 `변경이 용이`하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.

### 💡 다형성의 본질
- 인터페이스를 구현한 객체 인스턴스를 `실행 시점`에 유연하게 `변경`할 수 있다.
- 즉, 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

### 💡 역할과 구현을 분리
- `역할`과 `구현`으로 구분하면 세상이 `단순`해지고, `유연`해지며 `변경`도 편리해진다.
- 자바 언어의 다형성을 활용
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 `역할과 구현을 명확히 분리`
- 객체 설계 시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 생성 (역할 > 구현)
  - 인터페이스를 안정적으로 잘 설계하는 것이 중요하다.
- __장점__
  - 클라이언트는 `대상의 역할(인터페이스)`만 알면 된다.
  - 클라이언트는 구현 대상의 `내부 구조를 몰라도` 된다.
  - 클라이언트는 구현 대상의 `내부 구조가 변경`되어도 영향을 받지 않는다.
  - 클라이언트는 구현 `대상 자체를 변경`해도 영향을 받지 않는다.

### 3. 스프링과 객체 지향
- 스프링은 `다형성을 극대화`해서 이용할 수 있게 도와준다.
- 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.

- - -
## ✔ 좋은 객체 지향 설계의 5가지 원칙 (SOLID)
| 용어 | 풀이 | 내용 |
|:--------:|:--------:|:--------|
| SRP | 단일 책임 원칙 <br>(single responsibility principle) | - 한 클래스는 하나의 책임만 가져야 한다. <br>- 하나의 책임이라는 것은 모호하다. 즉, 클 수도 있고 작을 수도 있으며, 문맥과 상황에 따라 다르다. <br>- 중요한 기준은 변경이다. 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따르는 것 <br>- ex) UI 변경, 객체의 생성과 사용을 분리 |
| OCP | 개방-폐쇄 원칙 <br>(open-closed principle) | - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. <br>- MemberService 클라이언트가 구현 클래스를 직접 선택 <br>````java MemberRepository m = new MemoryMemberRepository(); // 기존 코드 ````<br>````java MemberRepository m = new JdbcMemberRepository(); // 변경 코드 ```` <br>- 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다. <br>- 분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다. <br>- 이 문제를 해결하기 위해서는 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.|
| LSP | 리스코프 치환 원칙 <br>(Liskov substitution principle) | 프로그램의 객체는 프로그램의 `정확성`을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다. <br>- ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능이며, 뒤로 가게 구현하면 LSP 위반! 느리더라도 앞으로 가야한다. |
| ISP | 인터페이스 분리 원칙 <br>(interface segregation principle) | - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. <br>- 자동차 인터페이스 --> 운전 인터페이스, 정비 인터페이스로 분리 <br>- 사용자 클라이언트 --> 운전자 클라이언트, 정비사 클라이언트로 분리 <br>- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않는다. <br>- 인터페이스가 명확해지고, 대체 가능성이 높아진다. |
| DIP | 의존관계 역전 원칙 <br>(dependency inversion principle) | - 프로그래머는 `추상화에 의존해야지, 구체화에 의존하면 안된다.` 의존성 주입은 이 원칙을 따르는 방법 중 하나 <br>- 즉, 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻 (역할에 의존!) <br>  - 그러나 OCP에서 설명한 MemberService는 인터페이스(추상화인 MemberRepository)에 의존하지만, 구현 클래스(구체화인 MemoryMemberRepository)도 동시에 의존한다. <br>````java MemberRepository m = new MemoryMemberRepository(); // DIP 위반 ```` |

### 💡 정리
- 객체 지향의 핵심은 `다형성`
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- 다형성 만으로는 `OCP`, `DIP`를 지킬 수 없다.
- 따라서, 부가적인 요소가 더 필요하다.


- - -
## ✔ 객체 지향 설계와 스프링
- 스프링은 다음 기술로 다형성 + `OCP, DIP`를 가능하게 지원
  - DI (Dependency Injection) : 의존관계, 의존성 주입
  - DI 컨테이너 제공
- 클라이언트 코드의 변경 없이 기능 확장
- 쉽게 부품을 교체하듯이 개발

